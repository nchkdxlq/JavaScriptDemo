<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>


<!--
	字符串, 字符串可以使用双引号、也可以使用单引号
--->
<script type="text/javascript">
	var x = "Bill Gates";
	// 在同一个作用域中，两个变量的名字相同为什么不报错呢？？？
	var carname = "Porsche 911";
	var carname = 'Porsche 911';

	var txt = "abcdefg";
	var length = txt.length;
	length = 10;

	// alert(length);

</script>

<!--
	转义字符，
--->
<script type="text/javascript">
	
	var x = "中国是瓷器的故乡，因此 china 与\"China（中国）\"同名。"
	// alert(x);


	var x = "It's good to see you again.";
	// alert(x);

	var x = "字符 \\ 被称为反斜杠。";
	// alert(x);

</script>

<!--
	字符串可以是对象
--->
<script type="text/javascript">
	
	var firstName = "Bill";
	// 为什么typeof 获取的类型为 undefined
	var type = typeof fistName;
	alert(type);

	// 通过new创建字符串， 请不要把字符串创建为对象。它会拖慢执行速度。
	var fistName = new String("Bill");
	type = typeof(fistName);

	var x = "Bill";             
	var y = new String("Bill");

	// (x == y) 为 true，因为 x 和 y 的值相等
	var msg = "x == y is " + (x == y);
	alert(msg);

	// (x === y) 为 false，因为 x 和 y 的类型不同（字符串与对象）
	var msg = "x === y is " + (x == y);
	alert(msg);

	var x = new String("Bill");             
	var y = new String("Bill");
	// (x === y) 为 false，因为 x 和 y 是不同的对象

	// JavaScript 对象无法进行对比，比较两个 JavaScript 对象将始终返回 false。

</script>

<!--
	字符串方法
--->
<script type="text/javascript">
	
	// 长度
	var txt = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	var sln = txt.length;

	// 查找子串
	var str = "The full name of China is the People's Republic of China.";
	var pos = str.indexOf("China"); // 返回字符串中在指定文本首次出现的索引

	var pos = str.lastIndexOf("China"); // 返回指定文本在字符串中最后一次出现的索引

	// 说明：如果未找到文本，indexOf() lastIndexOf() 均返回 -1.
	var pos = str.indexOf("USA"); // -1

	// indexOf() 从头往尾查；lastIndexOf()从尾往头查。他们都接受两个参数，第二个参数为开始查询的起始位置
	var pos = str.indexOf("China", 18); // 从下标为 18 的位置开始往尾查询
	var pos = str.lastIndexOf("China", 50); // 从下标为 50 的位置开始往头查询

	// search() 搜索特定值的字符串，并返回匹配的位置
	var pos = str.search("Republic");

	// indexOf() 、search() 比较
	// 相同点：1. 都从头往尾查询，并返回第一个匹配字符串的索引
	// 不同点：1. search()无法设置第二个参数，搜索的其实位置 2. indexOf()无法设置更强大的搜索值(正则表达式)

</script>

<!--
	提取子串
--->

<script type="text/javascript">
	var str = "0123456789";

	// slice(start, end);  [start, end) ，包含start下标对应的字符，但是不包含end下标对应的字符。
	// start、end代表的索引必须为有效的，并且end位置需要在start的后面，否则会返回空串。
	var sub = str.slice(1, 3); // 12
	alert(sub);

	// 如果参数为负数，则表示从字符串的尾部开始计数
	var sub = str.slice(-2, -1); // 8
	alert(sub);

	// slice还可以只传递一个参数，表示从指定索引开始到字符串尾部
	var sub = str.slice(5); // 56789
	alert(sub);

	// substring() substring() 类似于 slice(),不同之处在于 substring() 无法接受负的索引。

	var sub = str.substring(0, 2); // 01
	var sub = str.substring(5); //  56789

	// substr() 第一个参数为子串的其实索引，第二个参数为截取的长度
	var sub = str.substr(0, 3); //012

	// 省略第二个参数
	var sub = str.substr(5); // 56789 截取剩余部分

	//如果首个参数为负，则从字符串的结尾计算位置。
	var sub = str.substr(-2, 1); // 8

</script>


<!--
	替换字符串
--->

<script type="text/javascript">
	var str = "112233";

	// replace 方法不会改变调用它的字符串。它返回的是新字符串。 只替换首个匹配：

	var newStr = str.replace("1", "a"); // a12233 (指替换首个匹配)

	// 大小写敏感
	var str = "aAbbcc";
	var newStr = str.replace("a", "1"); // "1Abbcc"

	// 大小写不敏感替换
	var newStr = str.replace(/a/i, "1"); // "11bbcc"

	// 替换所有匹配, 使用正则表达式
	var str = "aabbccaa";
	var newStr = str.replace(/a/g, "1"); // "11bbcc11"

</script>


<!--
	大小写  其他
--->
<script type="text/javascript">
	
	// 大小写
	var str = "aAbBcC";
	var newStr = str.toUpperCase(); // "AABBCC"
	var newStr = str.toLowerCase(); // "aabbcc"

	// 字符串连接
	var text1 = "Hello";
	var text2 = "World";

	// concat() 连接两个或多个字符串：
	var text3 = text1.concat(" ", text2); // "Hello World"


	var text = "   Swift   ";
	var str = text.trim(); // trim() 方法删除字符串两端的空白符：

</script>

<!--
	字符提取
--->

<script type="text/javascript">
	var str = "abcde,f,g";
	// charAt() 方法返回字符串中指定下标（位置）的字符串：
	var ret = str.charAt(1); // b

	// charCodeAt() 方法返回字符串中指定索引的字符 unicode 编码
	var ret = str.charCodeAt(1);// 98

	// 属性访问（Property Access）
	var ret = str[1]; // b


	// 把字符串转换为数组 (还没明白？？？？？)
	var arr = str.split(","); // []
	alert(arr[0]);

</script>


</body>
</html>